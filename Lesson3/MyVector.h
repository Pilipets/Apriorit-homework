#ifndef CODEREVIEWTASK_MYVECTOR_HPP
#define CODEREVIEWTASK_MYVECTOR_HPP

#include <vector>
#include <string>
#include <algorithm>
#include <stdexcept>

/*
 * MyVector stores a collection of objects with their names.
 *
 * Your task is to find as many mistakes and drawbacks in this code
 * according to the presentation as you can.
 * Annotate these mistakes with comments.
 *
 * Once you have found all the mistakes, rewrite the code
 * so it would not change its original purpose
 * and it would contain no mistakes.
 * Try to make the code more efficient without premature optimization.
 *
*/

//Firstly, it recommended not to inherit own classes from STL containers by the standard
//unless it's required. Some useful links:
//https://www.researchgate.net/post/I_really_want_to_understand_if_there_is_any_reason_why_one_should_not_inherit_from_the_stl_vector_class_in_c2

//public inheritance means: MyVector is vector<T>
//private or composition - using vector<T> inside MyVector
//Actually, it seems, at least for me, that
//composition suits here more than inheritance. But it all depends on the usage of MyVector class - about that
//I can only guess

//I will apply several approaches to modify this code and which one is better is the choice of usage
//1. Keep the inheritance but add smart pointers to make the code niftier and avoid calling new, delete,
//reference counting system
//2. Use composition instead of inheritance with std::vector, wrap data with smart pointers

template <typename T>
class MyVector : public std::vector<T>
{
public:
	MyVector& operator =(const MyVector&other) = delete;
	//in case user would use this operator the behavior could be not the one expected
	//because we aren't decrementing the reference counting variable with the default copy assignment operator
	//clearing memory and so on and so forth
	
	//The rule of three, five
	//copy assignment operator code was generated by the compiler, but not the way it should be
	//So it's either incorrect behavior when using it or violating the rule of three after marking it as delete
	MyVector()
	{
		m_ref_ptr = new size_t(1); //
		m_names = new std::vector<std::string>(); //Could be replaced with shared_ptr
	}

	MyVector(const MyVector& other) :
		std::vector<T>(other), m_ref_ptr(other.m_ref_ptr), m_names(other.m_names)
	{
		(*m_ref_ptr)++; //++(*m_ref_ptr) is not a significant productivity increasing 
	}


	~MyVector()
	{
		if (--*m_ref_ptr == 0)
		{
			delete m_ref_ptr;
			delete m_names;
		}
	}

	void push_back(const T& obj, const std::string& name)
	{
		copy_names();

		std::vector<T>::push_back(obj);
		m_names->push_back(name);
		//if default allocator throws a bad_alloc exception here
		//we might made an extra copy of keys(T type), values(string) containers
		//but anyway it's not a problem to solve:)
	}

	std::pair<const T&, const std::string&> operator[](int index) const
	{
		if (index >= std::vector<T>::size())
		{
			throw new std::out_of_range("Index is out of range"); //We should throw an exception by value
			//in order to avoid memory leakages with memory allocated on the heap
			//throw std::out_of_range("Index is out of range");
		}
		return std::pair<const T&, const std::string&>(std::vector<T>::operator[](index), (*m_names)[index]);
	}

	const T& operator[](const std::string& name) const
	{
		std::vector<std::string>::const_iterator iter = std::find(m_names->begin(), m_names->end(), name);
		if (iter == m_names->end())
		{
			throw new std::invalid_argument(name + " is not found in the MyVector");
			//throw std::invalid_argument(name + " is not found in the MyVector");
		}

		return std::vector<T>::operator[](iter - m_names->begin());
	}

private:
	void copy_names()
	{
		if (*m_ref_ptr == 1)
		{
			return;
		}

		size_t* temp_ref_ptr = new size_t(1);
		std::vector<std::string>* temp_names = new std::vector<std::string>(*m_names);

		(*m_ref_ptr)--;
		m_ref_ptr = temp_ref_ptr;
		m_names = temp_names;
	}

private:
	// Use copy-on-write idiom for names for efficiency
	std::vector<std::string>* m_names; //we can actually wrap this two guys with the shared_ptr
	size_t* m_ref_ptr; //

	//And something which I found funny
	//In Clean Code: A Handbook of Agile Software Craftsmanship 
	//there is an explicit recommendation against the usage of m_ prefix:
	//You also don't need to prefix member variables with m_ anymore. Your classes and 
	//functions should be small enough that you don't need them. :)))))))))))
};


#endif //CODEREVIEWTASK_MYVECTOR_HPP
