/*Дан массив целых цисел A. Для каждого числа в массиве A необходимо найти индекс ближайшего меньшего 
элемемента, находящегося слева от этого числа. Индексы необходимо вернуть в виде массива G. Т.е., 
более формально:
Для каждого элемента A[i] необхоимо найти  G[i] = j, при котором j < i и  A[j] < A[i]. Если меньшего 
элемента не существует – устанавливаем индекс равным -1.
----------------------------------------------------------------------------------------------------------*/
/*Несколько замечаний по поводу условия. Формальное описание задачи не соответствует словесному, так
как в словесном необходимо найти индекс ближайшего предшествинника, который меньше текущего.
Формальным была бы корректная следующая формулировка задачи
Для каждого элемента A[i] необходимо найти G[i] = j, при котором j < i и A[j] < A[i] и для всех k: 
j<k<i A[k] >= A[i]
----------------------------------------------------------------------------------------------------------*/

/*Теперь переходим к решению задачи, сложность алгоритма  O(n)
Для решения задачи так же требуется O(n) дополнительной памяти в виде стека. Будем использовать стек
из stl. На шаге i в стеке будут хранится индексы эллементов предшественников arr[i], которые могут быть
ответом для эллементов arr[j], i<=j<n. При этом заметим следующие факты:
-Если arr[k] > arr[i], k>i, то нам нет смысла хранить элементы arr[j], 0<=j<i, так как
или arr[i] будет ближайшим меньшим предшественником для arr[k] или arr[p], где i<p<k. Поэтому при поиске 
ответа для arr[i] мы изымаем из стека элементы, больше arr[i]; при этом эти элементы будут предшественниками 
arr[i], то есть в исходном массиве иметь индексы 0<=j<i, но это не нарушает результата для arr[k], k>i
-Если же arr[k] <= arr[i], k>i, то извлекая из стека элементы предшественники arr[i], что больше arr[i] 
(формально arr[j] > arr[i], 0 <=j<i), мы не нарушим ответы для arr [k].
-----------------------------------------------------------------------------------------------------------

Алгоритм решения(arr - входной массив, g - выходной массив индексов)
1)Создаём пустой стек s
2)Для каждого arr[i], 0<=i<n
Пока стек не пустой и эллемент массива с индексом на вершине стека больше равен arr[i]
Извлекаем верхний эллемент стека
2.1) Если стек пустой, то меньшего предшественника нету(g[i] = -1)
2.2) Иначе g[i] = s.top()
2.3) Положить на стек i
*/
#include "Task13.h"
#include<string>
#include<iostream>
using std::cout;

void Test(int testNumber, const vector<int>& arr, const vector<int>& arr2);

int main()
{
	Test(1, { 3,2,1 }, 
		{ -1, -1, -1 });

	Test(2, { 4, 5, 2, 10, 8 }, 
		{ -1, 0, -1, 2, 2 });

	Test(3, { 1, 6, 4, 10, 2, 5 }, 
		{ -1, 0, 0,  2, 0, 4 });

	Test(4, { 1, 3, 0, 2, 5 }, 
		{ -1, 0, -1, 2, 3 });
	system("pause");
	return 0;
}

void Test(int testNumber, const vector<int>& inputArr, const vector<int>& resArr)
{
	cout << "------------Test " << testNumber << "----------------\n";
	cout << "Initial array: " << inputArr << "\n";
	cout << "Result array: " << prevSmaller(inputArr) << "\n";
	cout << "Binded answer: " << resArr << "\n";
	cout << std::string(35, '-') << "\n\n";
}
