/*Дан массив целых цисел A. Для каждого числа в массиве A необходимо найти индекс ближайшего меньшего 
элемемента, находящегося слева от этого числа. Индексы необходимо вернуть в виде массива G. Т.е., 
более формально:
Для каждого элемента A[i] необхоимо найти  G[i] = j, при котором j < i и  A[j] < A[i]. Если меньшего 
элемента не существует – устанавливаем индекс равным -1.
----------------------------------------------------------------------------------------------------------*/
/*Несколько замечаний по поводу условия. Формальное описание задачи не соответствует словесному, так
как в словесном необходимо найти ближайшего предшествинника, который меньше текущего.
Формальным была бы корректная следующая формулировка задачи
Для каждого элемента A[i] необходимо найти G[i] = j, при котором j < i и A[j] < A[i] и для всех k: 
j<k<i A[k] > A[i]
----------------------------------------------------------------------------------------------------------*/

/*Теперь к решению задачи, сложность алгоритма  O(n)
Для решения задачи так же требуется O(n) дополнительной памяти в виде стека. Будем использовать стек
из stl. На шаге i в стеке будут хранится индексы эллементов предшественников arr[i], которые могут быть
ответом для эллементов arr[j], i<=j<n. При этом заметим следующие факты:
-Если arr[k] > arr[i], k>i, то нам нет смысла хранить элементы arr[j], 0<= j< i, так как
или arr[i] будет ближайшим меньшим предшественником для arr[k] или arr[p], где i<p<k. Поэтому при поиске 
ответа для arr[i] мы изымаем из стека элементы, больше arr[i]; при этом эти элементы будут предшественниками 
arr[i], то есть в исходном массиве иметь индексы 0<=j<i, но это не нарушает результата для arr[k], k>i
-Если же arr[k] <= arr[i], k>i, то извлекая из стека элементы предшественники arr[i], что больше arr[i] 
(формально arr[j] > arr[i], 0 <=j<i), мы не нарушим ответы для arr [k].
-----------------------------------------------------------------------------------------------------------

Алгоритм решения(arr - входной массив, g - выходной массив индексов)
1)Создаём пустой стек s

2)Для каждого arr[i], 0<=i<n
Пока стек не пустой и эллемент массива с индексом на вершине стека больше равен arr[i]
Извлекаем верхний эллемент стека
2.1) Если стек пустой, то меньшего предшественника нету(g[i] = -1)
2.2) Иначе g[i] = s.top()
2.3) Положить на стек i
*/
#include<iostream>
#include<vector>
#include<stack>
#include<ostream>
using std::vector;

vector<int> prevSmaller(const vector<int> &arr); //более правильным показалось добавить в сигнатуру
//модификатор доступа const перед arr
std::ostream& operator <<(std::ostream& os, const vector<int>& arr);
int main()
{
	vector<int> a;
	a = { 3,2,1 };
	std::cout << prevSmaller(a);
	system("pause");
	return 0;
}

vector<int> prevSmaller(const vector<int>& arr)
{
	int n = arr.size();
	std::stack<int> s;
	vector<int> res(n);

	for (int i = 0; i < n; ++i) {
		while (!s.empty() && arr[s.top()] >= arr[i])
			s.pop();
		res[i] = s.empty() ? -1 : s.top();

		s.push(i);
	}
}

std::ostream& operator <<(std::ostream& os, const vector<int>& arr)
{

}
